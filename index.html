<!doctype html>
<html>
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

    <title>Javascript Classes</title>

    <link rel="icon" href="JS.png" type="image/gif" sizes="16x16">

    <link rel="stylesheet" href="dist/reset.css">
    <link rel="stylesheet" href="dist/reveal.css">
    <link rel="stylesheet" href="dist/theme/night.css" id="theme">

    <!-- Theme used for syntax highlighted code -->
    <link rel="stylesheet" href="plugin/highlight/monokai.css" id="highlight-theme">

    <style type="text/css">
        i {
            font-style: italic;
        }

        .highlight-line {
            background: rgba(255, 255, 255, .2);
        }

        .reveal a {
            color: inherit;
        }

        .reveal a:hover {
            color: inherit;
            text-decoration: underline;
        }
    </style>

</head>
<body>
<div class="reveal">
    <div class="slides">
        <section data-background="#FAD12C">
            <h1 style="font-size: 2.5em">
                OOP w/ Javascript
            </h1>
            <h5 class="fragment" data-fragment-index="2">
                Part I - Classes
            </h5>
        </section>
        <section>
            <section data-background="#FAD12C">
                <h2>The past</h2>
                <blockquote style="font-size: .5em">
                    <span>"You have to know the past to understand the present."</span> <br/>
                    <span style="font-size: .5em">- Carl Sagan</span>
                </blockquote>
            </section>
            <section>
                <p>
                    There were always very limited approaches to create class-like objects in Javascript.
                </p>
            </section>
            <section>
                <h4>
                    Javascript Objects
                </h4>
                <pre>
                    <code data-trim data-line-numbers>
                        var name = "Cthulhu";

                        var GreatOld = {
                            getName: function() {
                                return name;
                            }
                        };

                        console.log(GreatOld.getName()); // Cthulhu
                    </code>
                </pre>
            </section>
            <section>
                <h4>
                    Prototypes
                </h4>
                <pre>
                    <code data-trim data-line-numbers="1-3|1-7|9-11">
                        function GreatOld(name) {
                            this._name = name;
                        };

                        GreatOld.prototype.getName = function() {
                            return this._name;
                        };

                        var cthulhu = new GreatOld("Cthulhu");

                        console.log(cthulhu.getName()); // Output: Cthulhu
                    </code>
                </pre>
            </section>
            <section>
                <h4>
                    Prototypes and inheritance
                </h4>
                <pre>
                    <code data-trim data-noescape data-line-numbers="1-7|9-23|25-30">
                        function OuterGod(name) {
                            this._name = name;
                        };

                        OuterGod.prototype.getName = function() {
                            return this._name;
                        };

                        function GreatOld(name, housing) {
                            OuterGod.call(this, name);
                            this.housing = housing;
                        }

                        GreatOld.prototype = Object.create(OuterGod.prototype);
                        GreatOld.prototype.constructor = GreatOld;
                        GreatOld.prototype.getName = function() {
                            let name = OuterGod.prototype.getName.call(this);

                            return `Our lord and savor ${name}`;
                        }
                        GreatOld.prototype.getHousing = function() {
                            return this.housing;
                        }

                        var nyarlathotep = new OuterGod("Nyarlathotep");
                        var cthulhu = new GreatOld("Cthulhu", "R'lyeh");

                        console.log(nyarlathotep.getName()); // Nyarlathotep
                        console.log(cthulhu.getName()); // Our lord and savor Cthulhu
                        console.log(cthulhu.getHousing()); // R'lyeh
                    </code>
                </pre>
            </section>
        </section>
        <section>
            <section data-background="#FAD12C">
                <h2>
                    The present
                </h2>
                <p style="font-size: .8em">
                    The prototype syntax got wrapped by the new class syntax.<br/>
                    That means all prototyping-features are available for the classes.<br/><br/>
                    So OOP in Javascript becomes readable and fun again.
                </p>
                <p class="fragment" data-fragment-index="2" style="font-size: .8em">
                    But it's still limited compared to other languages.
                </p>
            </section>
            <section>
                <h3>
                    Defining classes
                </h3>
                <pre>
                    <code data-trim data-noescape data-line-numbers="1-9|11-29|13-14|20-21|31-36">
                        class OuterGod {
                            constructor(name) {
                                this._name = name;
                            }

                            getName() {
                                return this._name;
                            }
                        }

                        class GreatOld extends OuterGod {
                            constructor(name, housing) {
                                // OuterGod.call(this, name);
                                super(name);

                                this.housing = housing;
                            }

                            getName() {
                                // let name = OuterGod.prototype.getName.call(this);
                                let name = super.getName();

                                return `Our lord and savor ${name}`;
                            }

                            getHousing() {
                                return this.housing;
                            }
                        }

                        let nyarlathotep = new OuterGod("Nyarlathotep");
                        let cthulhu = new GreatOld("Cthulhu", "R'lyeh");

                        console.log(nyarlathotep.getName()); // Nyarlathotep
                        console.log(cthulhu.getName()); // Our lord and savor Cthulhu
                        console.log(cthulhu.getHousing()); // R'lyeh
                    </code>
                </pre>
            </section>
        </section>
        <section>
            <section data-background="#FAD12C">
                <h3>
                    More syntax and features
                </h3>
            </section>
            <section>
                <h3>
                    super();
                </h3>
                <p>
                    Comparable to PHPs <i>parent()</i>
                </p>
                <pre style="font-size: .35em">
                    <code data-trim data-line-numbers>
                        class OuterGod {
                            constructor(name) {
                                this._name = name;
                            }

                            getName() {
                                return this._name;
                            }
                        }

                        class GreatOld extends OuterGod {
                            constructor(name, housing) {
                                super(name);
                                this._housing = housing;
                            }

                            getHousing() {
                                return this._housing;
                            }
                        }

                        let cthulhu = new GreatOld("Cthulhu", "R'lyeh");

                        console.log(cthulhu.getName(), " dreams in ", cthulhu.getHousing()); // Cthulhu dreams in R'lyeh
                    </code>
                </pre>
                <p style="font-size: 18px">
                    Super is therefor like a reference to the extended <b><i>prototype</i></b>.
                </p>
            </section>
            <section>
                <h3>
                    Hoisting*
                </h3>
                <p>
                    While functions are hoisted, classes aren't!
                </p>
                <pre>
                    <code data-trim data-line-numbers>
                        let designer = new Designer(); // Instance of Designer

                        function Designer() {

                        }

                        // -----

                        let developer = new GreatOld(); // ReferenceError

                        class GreatOld {

                        }
                    </code>
                </pre>
                <i style="font-size: 14px">
                    *Hoisting is a JavaScript mechanism where variables and function declarations are moved to the top
                    of their scope before code execution.
                </i>
            </section>
            <section>
                <h3>
                    Getter and Setter methods
                </h3>
                <p style="font-size: 24px">
                    Allows e.g. validations, logging, async requests, ... when setting/getting data.<br/>
                    Comparable to PHPs <i>__get()</i> or <i>__set()</i>
                </p>
                <pre style="font-size: .5em">
                    <code data-trim data-line-numbers="6-12|19-21|14-16">
                        class GreatOld {
                            constructor(name) {
                                this._name = name;
                            }

                            set name(name) {
                                if (name.trim().length === 0) {
                                    throw new Error("Invalid value provided");
                                }

                                this._name = name;
                            }

                            get name() {
                                return this._name;
                            }
                        }

                        let cthulhu = new GreatOld("Cthulhu");  // Output: Cthulhu
                        cthulhu.name = "Peter"; // Output: Peter
                        cthulhu.name = ""; // Output: Error: Invalid value provided
                    </code>
                </pre>
            </section>

            <section>
                <h3>
                    Static methods
                </h3>
                <p style="font-size: 24px">
                    These are statically callable by using the classname, like in PHP.
                </p>
                <pre style="font-size: .5em">
                    <code data-trim data-line-numbers>
                        class OuterGod {
                          constructor(name) {
                            this._name = name;
                          }

                          static destroyWorld() {
                            return "Been there, done that.";
                          }
                        }

                        class GreatOld extends OuterGod {

                        }

                        console.log(OuterGod.destroyWorld()); // "Been there, done that."
                        console.log(GreatOld.destroyWorld()); // "Been there, done that."
                    </code>
                </pre>
            </section>

            <section>
                <h3>
                    Computed methods
                </h3>
                <p style="font-size: 24px">
                    Usage might be comparable to unbelievable, cosmic horror.
                </p>
                <pre style="font-size: .45em">
                    <code data-trim data-line-numbers>
                        // default
                        class GreatOld extends OuterGod {
                            destroyWorld() { }
                        }

                        // partial dynamic
                        const place = "World";

                        class GreatOld extends OuterGod {
                            ["destroy" + place]() { }
                        }

                        // full dynamic
                        const destroyWorldMethod = "destroyWorld";

                        class GreatOld extends OuterGod {
                            [destroyWorldMethod]() { }
                        }
                    </code>
                </pre>
            </section>
        </section>
        <section>
            <section data-background="#FAD12C" data-autoslide="2000">
                <h3 class="fragment">
                    Part II - Module syntax
                </h3>
            </section>
            <section data-auto-animate>
                <h3>
                    What and why?
                </h3>
                <ul style="font-size: .5em">
                    <li class="fragment">
                        Modules are reuseable code-fragments.
                    </li>
                    <li class="fragment">
                        They can be organized in a well-arranged folder structure.
                    </li>
                    <li class="fragment">
                        Similar to languages like C or JAVA, modules can only be imported when needed to lower the
                        overhead.
                    </li>
                    <li class="fragment">
                        When bundling: The size of the final bundle/application will change automatically.
                    </li>
                    <li class="fragment">
                        Only specific logic can be exposed, similar to public and private methods.
                    </li>
                </ul>
            </section>
            <section>
                <h3>
                    How?
                </h3>
                <h4 class="fragment">
                    Import / Export
                </h4>
            </section>
            <section>
                <h3>
                    export
                </h3>
                <p style="font-size: .5em">
                    You can export functions, const, let, var and classes but if have to happen on the top level.<br/>
                    Unexposed methods will not be available for import.
                </p>
                <pre style="font-size: .5em">
                    <code data-trim data-line-numbers="1-12|16-26|28">
                        // GreatOld.js
                        export const GreatOldEnum = {
                            CTHULHU: "Cthulhu"
                        };

                        export class GreatOld {
                            // ...
                        }

                        export function destroyWorld() {
                            // ...
                        }

                        // or

                        const GreatOldEnum = {
                            CTHULHU: "Cthulhu"
                        };

                        class GreatOld {
                            // ...
                        }

                        function destroyWorld() {
                            // ...
                        }

                        export { GreatOldEnum, GreatOld, destroyWorld }
                    </code>
                </pre>
            </section>
            <section>
                <h3>
                    import
                </h3>
                <p>
                    All variables/classes/functions which are exported are non-anonymous and can be imported by directly
                    naming them in the import-statement.
                </p>
                <pre style="font-size: .5em">
                    <code data-trim data-line-numbers>
                        // GreatOld.js
                        export const GreatOldEnum = {
                            CTHULHU: "Cthulhu"
                        };

                        export class GreatOld {
                            // ...
                        }
                    </code>
                </pre>
                <pre style="font-size: .5em">
                    <code data-trim data-line-numbers>
                        // app.js
                        import { GreatOld, GreatOldEnum }  from './GreatOld.js';
                    </code>
                </pre>
            </section>
            <section>
                <h3>
                    export default
                </h3>
                <p style="font-size: .5em">
                    Defining an <i>export default</i> in a module allows to expose an anonymous variable/function/class.<br/>
                    When importing a module, the <i>export default</i> will be referenced with a given name.<br/>
                </p>
                <pre style="font-size: .5em">
                    <code data-trim data-noescape data-line-numbers>
                        // GreatOld.js
                        export const GreatOldEnum = {
                            CTHULHU: "Cthulhu"
                        };

                        export <i><u>default</u></i> class {
                            // ...
                        }

                        // app.js
                        import <i><u>GreatOld</u></i>, {GreatOldEnum} from './GreatOld.js';
                    </code>
                </pre>
                <p style="font-size: .5em">
                    <b>There is only one <i>default</i> allowed per file.</b>
                </p>
            </section>
            <section>
                <h3>
                    import as alias
                </h3>
                <p style="font-size: .5em">
                    Sometimes classes have different pathes but the same name. Therefor you can alias the imports.
                </p>
                <pre style="font-size: .5em">
                    <code data-trim data-noescape data-line-numbers>
                        // app.js
                        import {NameEnum as GreatOldEnum} from './GreatOld.js';
                        import {NameEnum as OuterGodEnum} from './OuterGods.js';
                    </code>
                </pre>
            </section>
            <section>
                <h3>
                    Module => Object
                </h3>
                <p style="font-size: .5em">
                    With a little help of our friends <i>alias</i> and <i>wildcard</i> we can also move all exported
                    logic to a Javascript object.
                </p>
                <pre style="font-size: .5em">
                    <code data-trim data-noescape data-line-numbers>
                        // GreatOld.js
                        export const types = {
                            CTHULHU: "Cthulhu"
                        };

                        export function destroyWorld {
                            // ...
                        }

                        // app.js
                        import * as GreatOld from './GreatOld.js';

                        console.log(GreatOld.types); // { CTHULHU: "Cthulhu" }
                    </code>
                </pre>
                <p style="font-size: .5em">
                    Better use classes to create such an object. Alternatively <i>export default</i> a class instance of
                    you want to use singletonpatterns.
                </p>
            </section>
            <section>
                <h3>
                    Aggregation
                </h3>
                <p style="font-size: .5em">
                    Sometimes you want to combine multiple modules in one aggregated module.
                </p>
                <pre style="font-size: .5em">
                    <code data-trim data-noescape data-line-numbers="1-8|4,10-13|3,15-22">
                        // Folder structure
                        modules/
                            canvas.js
                            shapes.js
                            shapes/
                                circle.js
                                square.js
                                triangle.js

                        // shapes.js
                        export { Square } from './shapes/square.js';
                        export { Triangle } from './shapes/triangle.js';
                        export { Circle } from './shapes/circle.js';

                        // canvas.js
                        // before
                        import { Square } from './modules/square.js';
                        import { Circle } from './modules/circle.js';
                        import { Triangle } from './modules/triangle.js';

                        // after
                        import { Square, Circle, Triangle } from './modules/shapes.js';
                    </code>
                </pre>
            </section>
            <section>
                <h3>
                    Dynamic module loading
                </h3>
                <p style="font-size: .5em">
                    One of the newest features in browsers is to import modules dynamically witch is similar to the
                    wildcard import.
                </p>
                <pre style="font-size: .5em">
                    <code data-trim data-noescape data-line-numbers="10-13">
                        // GreatOld.js
                        export class GreatOld {
                            destroyWorld {
                                // ...
                            }
                        }

                        // app.js
                        someButton.addEventListener('click', () => {
                            import('./GreatOld.js').then((Module) => {
                                let cthulhu = new Module.GreatOld("Cthulhu");
                                cthulhu.destroyWorld();
                            })
                        });
                    </code>
                </pre>
            </section>
            <section>
                <h3>
                    Additional
                </h3>
                <ul>
                    <li>
                        <b>*.mjs</b> is a possible file extension for module files.<br/>
                        <span class="fragment">But caution, this is not fully supported by browsers and manly only for Node.js servers. But Babel can compile these files to JS-files.</span>
                    </li>
                </ul>
            </section>
        </section>
        <section>
            <section data-background="#FAD12C">
                <h2>
                    Summary
                </h2>
                <ul style="font-size: 32px">
                    <li class="fragment">
                        Use the class-syntax to create reuseable logic
                    </li>
                    <li class="fragment">
                        Organize your classes in modules
                    </li>
                    <li class="fragment">
                        Think about a reasonable exposure of logic
                    </li>
                    <li class="fragment">
                        Use processors like Babel to have the full support of new features as the Javascript-Specs might change fast.
                    </li>
                </ul>
            </section>
        </section>
        <section data-background="#FAD12C">
            <h2>
                Sources
            </h2>
            <ul style="font-size: 32px">
                <li>
                    <a href="https://thecodebarbarian.com/an-overview-of-es6-classes" target="_blank">An overview</a>
                </li>
                <li>
                    <a href="https://2ality.com/2015/02/es6-classes-final.html" target="_blank">ES6 Definitions</a>
                </li>
                <li>
                    <a href="https://developer.mozilla.org/de/docs/Web/JavaScript/Reference/Operators/class"
                       target="_blank">Class expression</a>
                </li>
                <li>
                    <a href="https://www.digitalocean.com/community/tutorials/understanding-hoisting-in-javascript"
                       target="_blank">Hoisting explained</a>
                </li>
                <li>
                    <a href="https://developer.mozilla.org/de/docs/Web/JavaScript/Guide/Modules"
                       target="_blank">Modules</a>
                </li>
            </ul>
        </section>
    </div>
</div>

<script src="dist/reveal.js"></script>
<script src="plugin/notes/notes.js"></script>
<script src="plugin/markdown/markdown.js"></script>
<script src="plugin/highlight/highlight.js"></script>
<script>
    Reveal.initialize({
        hash: true,
        plugins: [RevealMarkdown, RevealHighlight, RevealNotes]
    });
</script>

</body>
</html>
